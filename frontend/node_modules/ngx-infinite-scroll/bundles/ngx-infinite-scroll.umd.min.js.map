{"version":3,"file":"ngx-infinite-scroll.umd.min.js","sources":["../../src/services/ngx-ins-utils.ts","../../src/services/position-resolver.ts","../../src/services/scroll-register.ts","../../src/services/scroll-resolver.ts","../../src/services/axis-resolver.ts","../../src/modules/infinite-scroll.directive.ts","../../src/modules/ngx-infinite-scroll.module.ts"],"sourcesContent":["\n/**\n * @param {?} selector\n * @param {?} scrollWindow\n * @param {?} defaultElement\n * @return {?}\n */\nexport function resolveContainerElement(selector: string | any, scrollWindow, defaultElement): any {\n  const /** @type {?} */ hasWindow = window && window.hasOwnProperty('document');\n  const /** @type {?} */ containerIsString = selector && hasWindow && typeof(selector) === 'string';\n  let /** @type {?} */ container = containerIsString\n    ? window.document.querySelector(selector)\n    : selector;\n  if (!selector) {\n    container = scrollWindow ? window : defaultElement;\n  }\n  return container;\n}\n","import { Injectable, ElementRef } from '@angular/core';\nimport { AxisResolver } from './axis-resolver';\nimport { ContainerRef, IPositionElements, IPositionStats, IResolver } from '../models';\nexport class PositionResolver {\n/**\n * @param {?} options\n * @return {?}\n */\ncreate(options: IPositionElements): IResolver {\n    const /** @type {?} */ isWindow = this.isElementWindow(options.windowElement);\n    const /** @type {?} */ resolver: IResolver = {\n      axis: options.axis,\n      container: this.defineContainer(options.windowElement, isWindow),\n      isWindow,\n    };\n    return resolver;\n  }\n/**\n * @param {?} windowElement\n * @param {?} isContainerWindow\n * @return {?}\n */\ndefineContainer(windowElement: ContainerRef, isContainerWindow: boolean) {\n    const /** @type {?} */ container = (isContainerWindow || !windowElement.nativeElement)\n      ? windowElement\n      : windowElement.nativeElement;\n    return container;\n  }\n/**\n * @param {?} windowElement\n * @return {?}\n */\nisElementWindow(windowElement: ContainerRef): boolean {\n    const /** @type {?} */ isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n  }\n/**\n * @param {?} isContainerWindow\n * @param {?} windowElement\n * @return {?}\n */\ngetDocumentElement(isContainerWindow: boolean, windowElement) {\n    return isContainerWindow\n      ? windowElement.document.documentElement\n      : null;\n  }\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\ncalculatePoints (element: ElementRef, resolver: IResolver) {\n    return resolver.isWindow\n      ? this.calculatePointsForWindow(element, resolver)\n      : this.calculatePointsForElement(element, resolver);\n  }\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\ncalculatePointsForWindow (element: ElementRef, resolver: IResolver): IPositionStats {\n    const { axis, container, isWindow } = resolver;\n    const /** @type {?} */ offsetHeightKey = axis.offsetHeightKey();\n    const /** @type {?} */ clientHeightKey = axis.clientHeightKey();\n    const /** @type {?} */ topKey = axis.topKey();\n    // container's height\n    const /** @type {?} */ height = this.height(container, isWindow, offsetHeightKey, clientHeightKey);\n    // scrolled until now / current y point\n    const /** @type {?} */ scrolledUntilNow = height + this.pageYOffset(this.getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    const /** @type {?} */ nativeElementHeight = this.height(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    const /** @type {?} */ totalToScroll = this.offsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n    return { height, scrolledUntilNow, totalToScroll };\n  }\n/**\n * @param {?} element\n * @param {?} resolver\n * @return {?}\n */\ncalculatePointsForElement (element: ElementRef, resolver: IResolver) {\n    const { axis, container, isWindow } = resolver;\n    const /** @type {?} */ offsetHeightKey = axis.offsetHeightKey();\n    const /** @type {?} */ clientHeightKey = axis.clientHeightKey();\n    const /** @type {?} */ scrollTop = axis.scrollTopKey();\n    const /** @type {?} */ scrollHeight = axis.scrollHeightKey();\n    const /** @type {?} */ topKey = axis.topKey();\n\n    const /** @type {?} */ height = this.height(container, isWindow, offsetHeightKey, clientHeightKey);\n    // perhaps use this.container.offsetTop instead of 'scrollTop'\n    const /** @type {?} */ scrolledUntilNow = container[scrollTop];\n    let /** @type {?} */ containerTopOffset = 0;\n    const /** @type {?} */ offsetTop = this.offsetTop(container, axis, isWindow);\n    if (offsetTop !== void 0) {\n      containerTopOffset = offsetTop;\n    }\n    const /** @type {?} */ totalToScroll = container[scrollHeight];\n    return { height, scrolledUntilNow, totalToScroll };\n  }\n/**\n * @param {?} elem\n * @param {?} isWindow\n * @param {?} offsetHeightKey\n * @param {?} clientHeightKey\n * @return {?}\n */\nprivate height (elem: any, isWindow: boolean, offsetHeightKey: string, clientHeightKey: string) {\n    if (isNaN(elem[offsetHeightKey])) {\n      return this.getDocumentElement(isWindow, elem)[clientHeightKey];\n    } else {\n      return elem[offsetHeightKey];\n    }\n  }\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nprivate offsetTop (elem: ContainerRef, axis: AxisResolver, isWindow: boolean) {\n    const /** @type {?} */ topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) { // || elem.css('none')) {\n      return;\n    }\n    return elem.getBoundingClientRect()[topKey] + this.pageYOffset(elem, axis, isWindow);\n  }\n/**\n * @param {?} elem\n * @param {?} axis\n * @param {?} isWindow\n * @return {?}\n */\nprivate pageYOffset (elem: ContainerRef, axis: AxisResolver, isWindow: boolean) {\n    const /** @type {?} */ pageYOffset = axis.pageYOffsetKey();\n    const /** @type {?} */ scrollTop = axis.scrollTopKey();\n    const /** @type {?} */ offsetTop = axis.offsetTopKey();\n\n    if (isNaN(window[pageYOffset])) {\n      return this.getDocumentElement(isWindow, elem)[scrollTop];\n    } else if (elem.ownerDocument) {\n      return elem.ownerDocument.defaultView[pageYOffset];\n    } else {\n      return elem[offsetTop];\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction PositionResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nPositionResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nPositionResolver.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { ContainerRef, IPositionStats, IScrollStats } from '../models';\nimport { Injectable, ElementRef } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport'rxjs/add/observable/fromEvent';\nimport'rxjs/add/observable/of';\nimport'rxjs/add/operator/sampleTime';\nimport'rxjs/add/operator/filter';\nimport'rxjs/add/operator/mergeMap';\n\nexport interface IScrollRegisterConfig {\n  container: ContainerRef;\n  throttleDuration: number;\n  filterBefore: () => boolean;\n  mergeMap: Function;\n  scrollHandler: (value: any) => void;\n}\nexport class ScrollRegister {\n/**\n * @param {?} options\n * @return {?}\n */\nattachEvent (options: IScrollRegisterConfig): Subscription {\n    const /** @type {?} */ scroller$: Subscription = Observable.fromEvent(options.container, 'scroll')\n      .sampleTime(options.throttleDuration)\n      .filter(options.filterBefore)\n      .mergeMap((ev: any) => Observable.of(options.mergeMap(ev)))\n      .subscribe(options.scrollHandler);\n    return scroller$;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollRegister_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollRegister.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollRegister.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { IPositionStats, IScrollerConfig } from '../models';\nimport { Injectable } from '@angular/core';\nexport class ScrollResolver {\npublic lastScrollPosition: number = 0;\n/**\n * @param {?} container\n * @param {?} config\n * @param {?} scrollingDown\n * @return {?}\n */\nshouldScroll (container: IPositionStats, config: IScrollerConfig, scrollingDown: boolean) {\n    const /** @type {?} */ distance = config.distance;\n    let /** @type {?} */ remaining: number;\n    let /** @type {?} */ containerBreakpoint: number;\n    if (scrollingDown) {\n      remaining = container.totalToScroll - container.scrolledUntilNow;\n      containerBreakpoint = container.height * distance.down + 1;\n    } else {\n      remaining = container.scrolledUntilNow;\n      containerBreakpoint = container.height * distance.up + 1;\n    }\n    const /** @type {?} */ shouldScroll: boolean = remaining <= containerBreakpoint;\n    this.lastScrollPosition = container.scrolledUntilNow;\n    return shouldScroll;\n  }\n/**\n * @param {?} container\n * @return {?}\n */\nisScrollingDown (container: IPositionStats) {\n    return this.lastScrollPosition < container.scrolledUntilNow;\n  }\n/**\n * @param {?} container\n * @param {?} config\n * @return {?}\n */\ngetScrollStats (container: IPositionStats, config: IScrollerConfig) {\n    const /** @type {?} */ isScrollingDown = this.isScrollingDown(container);\n    const /** @type {?} */ shouldScroll = this.shouldScroll(container, config, isScrollingDown);\n    return { isScrollingDown, shouldScroll };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction ScrollResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nScrollResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nScrollResolver.ctorParameters;\n/** @type {?} */\nScrollResolver.prototype.lastScrollPosition;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\nexport class AxisResolver {\n/**\n * @param {?=} vertical\n */\nconstructor(private vertical: boolean = true) {\n  }\n/**\n * @return {?}\n */\nclientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }\n/**\n * @return {?}\n */\noffsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }\n/**\n * @return {?}\n */\nscrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }\n/**\n * @return {?}\n */\npageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }\n/**\n * @return {?}\n */\noffsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }\n/**\n * @return {?}\n */\nscrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }\n/**\n * @return {?}\n */\ntopKey() { return this.vertical ? 'top' : 'left'; }\n}\n\nfunction AxisResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nAxisResolver.prototype.vertical;\n}\n\n","import { InfiniteScrollEvent, IScrollStats, IPositionStats, IResolver } from '../models';\nimport {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { PositionResolver } from '../services/position-resolver';\nimport { ScrollRegister, IScrollRegisterConfig } from '../services/scroll-register';\nimport { ScrollResolver } from '../services/scroll-resolver';\nimport { AxisResolver } from '../services/axis-resolver';\nimport { resolveContainerElement } from '../services/ngx-ins-utils';\n\nimport { Subscription } from 'rxjs/Subscription';\nexport class InfiniteScrollDirective implements OnDestroy, OnInit, OnChanges {\n   scrolled = new EventEmitter<InfiniteScrollEvent>();\n   scrolledUp = new EventEmitter<InfiniteScrollEvent>();\n\n   infiniteScrollDistance: number = 2;\n   infiniteScrollUpDistance: number = 1.5;\n   infiniteScrollThrottle: number = 300;\n   infiniteScrollDisabled: boolean = false;\n   infiniteScrollContainer: any = null;\n   scrollWindow: boolean = true;\n   immediateCheck: boolean = false;\n   horizontal: boolean = false;\n   alwaysCallback: boolean = false;\nprivate disposeScroller: Subscription;\n/**\n * @param {?} element\n * @param {?} zone\n * @param {?} positionResolver\n * @param {?} scrollRegister\n * @param {?} scrollerResolver\n */\nconstructor(\nprivate element: ElementRef,\nprivate zone: NgZone,\nprivate positionResolver: PositionResolver,\nprivate scrollRegister: ScrollRegister,\nprivate scrollerResolver: ScrollResolver\n  ) {}\n/**\n * @return {?}\n */\nngOnInit() {\n    this.setup();\n  }\n/**\n * @param {?} __0\n * @return {?}\n */\nngOnChanges({ infiniteScrollContainer }: SimpleChanges) {\n    const /** @type {?} */ scrollContainerChanged = infiniteScrollContainer && !infiniteScrollContainer.firstChange;\n    if (scrollContainerChanged) {\n      this.destroyScroller();\n      this.setup();\n    }\n  }\n/**\n * @return {?}\n */\nsetup() {\n    if (typeof window !== 'undefined') {\n      this.zone.runOutsideAngular(() => {\n        const /** @type {?} */ containerElement = resolveContainerElement(this.infiniteScrollContainer, this.scrollWindow, this.element);\n        const /** @type {?} */ resolver = this.positionResolver.create({\n          axis: new AxisResolver(!this.horizontal),\n          windowElement: containerElement,\n        });\n        const /** @type {?} */ options: IScrollRegisterConfig = {\n          container: resolver.container,\n          filterBefore: () => !this.infiniteScrollDisabled,\n          mergeMap: () => this.positionResolver.calculatePoints(this.element, resolver),\n          scrollHandler: (container: IPositionStats) => this.handleOnScroll(container),\n          throttleDuration: this.infiniteScrollThrottle\n        };\n        this.disposeScroller = this.scrollRegister.attachEvent(options);\n      });\n    }\n  }\n/**\n * @param {?} container\n * @return {?}\n */\nhandleOnScroll(container: IPositionStats) {\n    const /** @type {?} */ distance = {\n      down: this.infiniteScrollDistance,\n      up: this.infiniteScrollUpDistance\n    };\n    const /** @type {?} */ scrollStats: IScrollStats = this.scrollerResolver.getScrollStats(container, { distance });\n    if (this.shouldTriggerEvents(scrollStats.shouldScroll)) {\n      const /** @type {?} */ infiniteScrollEvent: InfiniteScrollEvent = {\n        currentScrollPosition: container.scrolledUntilNow\n      };\n      if (scrollStats.isScrollingDown) {\n        this.onScrollDown(infiniteScrollEvent);\n      } else {\n        this.onScrollUp(infiniteScrollEvent);\n      }\n    }\n  }\n/**\n * @param {?} shouldScroll\n * @return {?}\n */\nshouldTriggerEvents(shouldScroll: boolean) {\n    return (this.alwaysCallback || shouldScroll) && !this.infiniteScrollDisabled;\n  }\n/**\n * @return {?}\n */\nngOnDestroy () {\n    this.destroyScroller();\n  }\n/**\n * @param {?=} data\n * @return {?}\n */\nonScrollDown(data: InfiniteScrollEvent = { currentScrollPosition: 0 }) {\n    this.zone.run(() => this.scrolled.emit(data));\n  }\n/**\n * @param {?=} data\n * @return {?}\n */\nonScrollUp(data: InfiniteScrollEvent = { currentScrollPosition: 0 }) {\n    this.zone.run(() => this.scrolledUp.emit(data));\n  }\n/**\n * @return {?}\n */\ndestroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Directive, args: [{\n  providers: [ScrollResolver],\n  selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]',\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ElementRef, },\n{type: NgZone, },\n{type: PositionResolver, },\n{type: ScrollRegister, },\n{type: ScrollResolver, },\n];\nstatic propDecorators: {[key: string]: DecoratorInvocation[]} = {\n'scrolled': [{ type: Output },],\n'scrolledUp': [{ type: Output },],\n'infiniteScrollDistance': [{ type: Input },],\n'infiniteScrollUpDistance': [{ type: Input },],\n'infiniteScrollThrottle': [{ type: Input },],\n'infiniteScrollDisabled': [{ type: Input },],\n'infiniteScrollContainer': [{ type: Input },],\n'scrollWindow': [{ type: Input },],\n'immediateCheck': [{ type: Input },],\n'horizontal': [{ type: Input },],\n'alwaysCallback': [{ type: Input },],\n};\n}\n\nfunction InfiniteScrollDirective_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollDirective.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollDirective.ctorParameters;\n/** @type {?} */\nInfiniteScrollDirective.propDecorators;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrolled;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrolledUp;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollDistance;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollUpDistance;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollThrottle;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollDisabled;\n/** @type {?} */\nInfiniteScrollDirective.prototype.infiniteScrollContainer;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollWindow;\n/** @type {?} */\nInfiniteScrollDirective.prototype.immediateCheck;\n/** @type {?} */\nInfiniteScrollDirective.prototype.horizontal;\n/** @type {?} */\nInfiniteScrollDirective.prototype.alwaysCallback;\n/** @type {?} */\nInfiniteScrollDirective.prototype.disposeScroller;\n/** @type {?} */\nInfiniteScrollDirective.prototype.element;\n/** @type {?} */\nInfiniteScrollDirective.prototype.zone;\n/** @type {?} */\nInfiniteScrollDirective.prototype.positionResolver;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollRegister;\n/** @type {?} */\nInfiniteScrollDirective.prototype.scrollerResolver;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScrollDirective } from './infinite-scroll.directive';\nimport { PositionResolver } from '../services/position-resolver';\nimport { ScrollRegister } from '../services/scroll-register';\nexport class InfiniteScrollModule { static decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{\n  declarations: [InfiniteScrollDirective],\n  exports: [InfiniteScrollDirective],\n  imports: [],\n  providers: [\n    PositionResolver,\n    ScrollRegister\n  ]\n}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction InfiniteScrollModule_tsickle_Closure_declarations() {\n/** @type {?} */\nInfiniteScrollModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nInfiniteScrollModule.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"],"names":["resolveContainerElement","selector","scrollWindow","defaultElement","hasWindow","window","hasOwnProperty","containerIsString","container","document","querySelector","PositionResolver","prototype","create","options","isWindow","this","isElementWindow","windowElement","axis","defineContainer","isContainerWindow","nativeElement","some","obj","Object","toString","call","includes","getDocumentElement","documentElement","calculatePoints","element","resolver","calculatePointsForWindow","calculatePointsForElement","offsetHeightKey","clientHeightKey","height","topKey","scrolledUntilNow","pageYOffset","nativeElementHeight","totalToScroll","offsetTop","scrollTop","scrollTopKey","scrollHeight","scrollHeightKey","elem","isNaN","getBoundingClientRect","pageYOffsetKey","offsetTopKey","ownerDocument","defaultView","decorators","type","Injectable","ctorParameters","ScrollRegister","attachEvent","Observable","fromEvent","sampleTime","throttleDuration","filter","filterBefore","mergeMap","ev","of","subscribe","scrollHandler","ScrollResolver","lastScrollPosition","shouldScroll","config","scrollingDown","remaining","containerBreakpoint","distance","down","up","isScrollingDown","getScrollStats","AxisResolver","vertical","InfiniteScrollDirective","zone","positionResolver","scrollRegister","scrollerResolver","scrolled","EventEmitter","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","horizontal","alwaysCallback","ngOnInit","setup","ngOnChanges","_a","firstChange","destroyScroller","_this","runOutsideAngular","containerElement","handleOnScroll","disposeScroller","scrollStats","shouldTriggerEvents","infiniteScrollEvent","currentScrollPosition","onScrollDown","onScrollUp","ngOnDestroy","data","run","emit","unsubscribe","Directive","args","providers","ElementRef","NgZone","propDecorators","Output","Input","InfiniteScrollModule","NgModule","declarations","exports","imports"],"mappings":"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"}